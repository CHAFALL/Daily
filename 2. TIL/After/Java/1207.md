# 1207 TIL

## 잡다한 것

- 부모는 자식을 품을 수 있지만 자식은 부모를 품을 수 없다.

- 부모는 자식의 기술들을 나이가 먹어서 써먹을 수 없다.

- 다운 캐스팅이 성공하면 부모는 자식의 기술들도 사용이 가능하다. (성공 가능 여부 파악을 하기 위해 instanceof가 쓰인다.)

- 부모는 자식이 새로 고안한 부모의 기술은 써먹어야만 한다.(오버라이딩.존재시)

- 메소드 추출 단축키
  
  - Ctrl + Alt + M

- 다형성 참조
  ![](1207_assets/2023-12-07-10-33-13-image.png)
  ![](1207_assets/2023-12-07-10-37-48-image.png)
  
  - parent 타입은 본인 것만 알고 있으므로, 자식의 기능은 호출 불가.
  
  ![](1207_assets/2023-12-07-10-41-33-image.png)
  
  ![](1207_assets/2023-12-07-10-47-19-image.png)
  ![](1207_assets/2023-12-07-10-47-41-image.png)

- 다형성과 캐스팅
  ![](1207_assets/2023-12-07-10-58-02-image.png)
  ![](1207_assets/2023-12-07-10-58-16-image.png)
  ![](1207_assets/2023-12-07-10-58-30-image.png)
  ![](1207_assets/2023-12-07-10-58-48-image.png)
  ![](1207_assets/2023-12-07-11-00-26-image.png)
  ![](1207_assets/2023-12-07-11-00-36-image.png)

- 캐스팅의 종류
  ![](1207_assets/2023-12-07-11-02-09-image.png)
  ![](1207_assets/2023-12-07-11-02-25-image.png)
  
  - 여기서 왜 괄호를 한번 더 치는 것 같지?? 의문을 가질 수 있다.
    
    - 연산자 우선순위가 `((Child) poly).childMethod();`에서  `(Child) poly` 보다  `poly.childMethod()`가 더 우선시 되므로 앞에 괄호를 써서 우선순위를 바꿔줘야 한다.
  
  ![](1207_assets/2023-12-07-11-10-18-image.png)
  ![](1207_assets/2023-12-07-11-10-32-image.png)

- 다운캐스팅과 주의점
  ![](1207_assets/2023-12-07-11-18-09-image.png)
  ![](1207_assets/2023-12-07-11-18-18-image.png)
  ![](1207_assets/2023-12-07-11-18-29-image.png)
  ![](1207_assets/2023-12-07-11-18-44-image.png)
  ![](1207_assets/2023-12-07-11-18-57-image.png)
  ![](1207_assets/2023-12-07-11-19-10-image.png)
  ![](1207_assets/2023-12-07-11-19-20-image.png)
  
  - 그러면 인스턴스가 뭔지를 알아야 어떻게든 하지 않겠어???
    
    - 그걸 알게해주는 것이 instanceof이다.

- instanceof
  ![](1207_assets/2023-12-07-11-40-53-image.png)
  
  - ex
    ![](1207_assets/2023-12-07-11-42-39-image.png)
  
  ![](1207_assets/2023-12-07-11-41-26-image.png)
  
  ![](1207_assets/2023-12-07-11-46-02-image.png)![](1207_assets/2023-12-07-11-45-33-image.png)

- 다형성과 메서드 오버라이딩
  ![](1207_assets/2023-12-07-11-54-21-image.png)
  ![](1207_assets/2023-12-07-11-55-11-image.png)
  ![](1207_assets/2023-12-07-11-55-21-image.png)
  ![](1207_assets/2023-12-07-11-55-36-image.png)
  ![](1207_assets/2023-12-07-11-55-44-image.png)

- 다형성 활용
  ![](1207_assets/2023-12-07-13-58-58-image.png)
  ![](1207_assets/2023-12-07-14-05-54-image.png)
  ![](1207_assets/2023-12-07-14-06-05-image.png)
  ![](1207_assets/2023-12-07-14-06-29-image.png)
  ![](1207_assets/2023-12-07-14-06-42-image.png)
  ![](1207_assets/2023-12-07-14-10-59-image.png)
  ![](1207_assets/2023-12-07-14-11-31-image.png)
  ![](1207_assets/2023-12-07-14-17-02-image.png)

- 추상 클래스
  ![](1207_assets/2023-12-07-14-21-53-image.png)
  ![](1207_assets/2023-12-07-14-22-03-image.png)
  ![](1207_assets/2023-12-07-14-44-47-image.png)
  ![](1207_assets/2023-12-07-14-45-04-image.png)
  
  - 내(부모)가 말해놓은 것들, 자식들아 모두 구현해라이!!

- 인터페이스
  ![](1207_assets/2023-12-07-14-49-55-image.png)
  ![](1207_assets/2023-12-07-14-50-08-image.png)
  
  - 빈 껍데기에 왠 멤버 변수??
    
    - 오케이 상수까지는 인정해줄게.
  
  ![](1207_assets/2023-12-07-14-53-03-image.png)
  ![](1207_assets/2023-12-07-14-53-11-image.png)
  
  ![](1207_assets/2023-12-07-15-01-51-image.png)
  ![](1207_assets/2023-12-07-15-02-03-image.png)

- 인터페이스 - 다중 구현
  ![](1207_assets/2023-12-07-15-49-51-image.png)
  ![](1207_assets/2023-12-07-15-50-23-image.png)
  ![](1207_assets/2023-12-07-15-50-38-image.png)
  
  - 즉, 자식에서 오버라이딩으로 구현이 되어있어서 함수가 호출이 될 때 오버라이딩이 된 자식으로 호출되므로 다이아몬드문제가 발생하지 않는다. (부모를 무엇을 선택할 지 고민할 필요도 없이 오버라이딩을 한 자식으로 가므로)
    
    - 그래서 다중 구현 가능. 
  
  - 다중 구현 예
    ![](1207_assets/2023-12-07-15-58-56-image.png)

- OCP(Open-Closed Principle) 원칙
  
  ![](1207_assets/2023-12-07-17-19-52-image.png)

- 뒷 부분은 좀 다시 볼 필요가 있을지도??? (막히면..)

- 최소한으로 추가적으로 자바 예외 처리와 자바 컬렉션까지는 알고 스프링으로 넘어가기!!

## 10장. 자바는 상속이라는 것이 있어요

- 자식이 상속을 받으면 부모 클래스에 선언되어 있는 public 및 protected로 선언되어 있는 모든 변수와 메소드를 내가 갖고 있는 것처럼 사용 가능
  
  - 즉, 다른 패키지에 선언된 부모 클래스의 접근 제어자가 없거나 private로 선언된 것들은 자식 클래스에서 사용 불가.

- 여러분들은 Parent 클래스의 메소드를 호출하지도 않았는데, 확장을 한 클래스가 생성자를 호출하면, 자동으로 부모 클래스의 기본 생성자(매개 변수가 아무것도 없는 생성자)가 호출된다.
  
  - 만약에 부모 클래스에 기본 생성자가 없다면???
    
    - 오류 발생!!
    
    - 매개 변수가 있는 생성자를 만들었을 경우에는 기본 생성자는 자동으로 만들어지지 않는다.
      
      - 해결법
        
        1. 부모 클래스에 "매개 변수가 없는" 기본 생성자를 만든다.
        
        2. 자식 클래스에서 부모 클래스의 생성자를 명시적으로 지정하는 super()를 사용한다.
           
           - 예를 들어 super("ChildArg")라고 지정하면 부모 클래스의 생성자 중 String 타입을 매개 변수로 받을 수 있는 생성자를 찾는다.
           
           - 또 만약에 매개변수가 있는 생성자가 여러개 있을 때 super(null)라고 지정하면 어떻게 될까???
             
             - 오류 발생
             
             - 클래스로의 참조가 매우 모호해요...
             
             - null을 넘겨주면 어떤 클래스를 찾아가야 하는지를 자바 컴파일러가 마음대로 정할 수 x
             
             - 따라서 super()를 사용하여 생성자를 호출할 때에는 모호하게 null를 넘기는 것보다는 호출하고자 하는 생성자의 기본 타입을 넘겨주는 것이 좋다.

- 부모 클래스의 생성자를 호출하는 super()는 반드시 자식 클래스의 생성자에서 가장 첫줄에 선언되어야만 한다.

- 자바에서는 다중 상속이 안 된다. 
  
  - 즉, extends 뒤에는 클래스가 두 개 이상 나열되면 안된다.

- 메소드 오버라이딩
  
  - 부모 클래스에서의 리턴 타입을 메소드 오버라이딩으로 마음대로 바꿀 수는 없다.
  
  - 접근 제어자는 어느정도는 바꿀 수 있다.
    
    - 접근 제어자가 확대되는 것은 가능하지만 축소되는 것은 문제가 된다.
    
    - ex) 부모 클래스에서 public으로 선언한 것을 자식이 private로 선하면 안 된다.
  
  - 정리
    
    - 메소드 오버라이딩은 부모 클래스의 메소드와 동일한 시그니처를 갖는 자식 클래스의 메소드가 존재할 때 성립
    
    - 오버라이딩된 메소드는 부모 클래스와 동일한 리턴 타입을 가져야만 한다.
    
    - 오버라이딩된 메소드의 접근 제어자는 부모 클래스에 있는 메소드와 달라도 되지만, 접근 권한이 확장되는 경우에만 허용된다.  

- 참조 자료형의 형 변환
  
  - 부모는 자식을 품을 수 있지만, 자식은 부모를 품을 수 없다.
  
  - `ParentCasting obj = new ChildCasting()` (가능)
  
  - `ChildCasting obj2 = new ParentCasting()` (불가능)
  
  - 왜 이럴까?
    
    - 자식 클래스에서는 부모 클래스에 있는 메소드와 변수들을 사용가능
    
    - 부모 클래스에서는 자식 클래스에 있는모든 메소드와 변수들을 사용할 수 없다.
    
    - 데이터 구조를 보면 알 수 있음.
  
  - 자식 타입의 객체를 부모 타입으로 형 변환 하는 것은 자동으로 된다.
  
  - 부모 타입의 객체를 자식 타입으로 형 변환을 할 때에는 명시적으로 타입을 지정해 주어야 한다. 이때, 부모 타입의 실제 객체는 자식 타입이어야만 한다.

- 다형성
  
  - 형 변환을 하더라도, 실제 호출되는 것은 원래 객체에 있는 메소드가 호출됨.

- 정리해 봅시다
  
  1. 상속을 받는 클래스의 선언문에 사용하는 키워드는 무엇인가요?
     
     - extends
  
  2. 상속을 받은 클래스의 생성자를 수행하면 부모의 생성자도 자동으로 수행되나요?
     
     - O
  
  3. 부모 클래스의 생성자를 자식 클래스에서 직접 선택하려고 할 때 사용하는 예약어는 무엇인가요?
     
     - super
  
  4. 메소드 Overriding과 Overloading을 정확하게 설명해 보세요.
     
     - (p 252) 간단하게 메소드 오버라이딩(메소드 Overriding)은 "**복제**", 메소드 오버로딩(Overloading)은 "**확장**"이라고 생각할 수 있다.
     - 메소드 오버라이딩 : 부모 클래스의 메소드 시그니처(동일하게 선언됨)를 복제해서 자식 클래스에서 새로운 것을 만들어 내어 부모 클래스의 기능은 무시하고, 자식 클래스에서 덮어쓰는 개념
     - 메소드 오버로딩 : 메소드의 매개 변수들을 확장하는 개념
  
  5. A가 부모, B가 자식 클래스라면 A a = new B(); 형태로 객체 생성이 가능한가요?
     
     - O, 이를 **참조 자료형의 형변환**이라고 한다.
     - 참조 자료형의 형변환 : 자식 클래스의 타입을 부모 클래스의 타입으로 **명시적**으로 형변환하는 것
       ![](1207_assets/2023-12-07-21-14-43-image.png)
  
  6. 명시적으로 형 변환을 하기 전에 타입을 확인하려면 어떤 예약어를 사용해야 하나요?
     
     - instanceof
  
  7. 6에서 사용한 예약어의 좌측에는 어떤 값이, 우측에는 어떤 값이 들어가나요?
     
     - 객체, 클래스 타입
       ![](1207_assets/2023-12-07-21-15-25-image.png)
  
  8. 6의 예약어의 수행 결과는 어떤 타입으로 제공되나요?
     
     - boolean
  
  9. Polymorphism이라는 것은 도대체 뭔가요?
     
     - (p 261) **다형성**이다.
     - 다형성 : 형 변환을 하더라도 실제 호출되는 것은 원래 객체에 있는 메소드가 호출된다는 것
