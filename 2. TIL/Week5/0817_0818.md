# 0817_0818 TIL

## 잡다한 것

---

## Quene(큐)

- 큐의 특성
  
  - 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
    
    - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
  
  - 선입선출구조(FIFO)
    
    - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제 된다.

- 큐의 구조 및 기본연산
  
  <img title="" src="0817_0818_assets/2023-08-17-09-05-28-image.png" alt="" width="442">
  <img src="0817_0818_assets/2023-08-17-09-07-28-image.png" title="" alt="" width="426">

- 큐의 연산 과정
  
  <img src="0817_0818_assets/2023-08-17-09-09-55-image.png" title="" alt="" width="414">
  <img src="0817_0818_assets/2023-08-17-09-10-17-image.png" title="" alt="" width="408">
  
  두 개의 인덱스를 가진다고 생각(들어온 애, 나간 애의 위치)
  front는 마지막 삭제 위치, rear은 마지막 저장 위치
  
  front와 rear이 만날 때는 두번 있다. (처음과 마지막)

### 선형큐

- 1차원 배열을 이용한 큐
  
  - 큐의 크기 = 배열의 크기
  
  - front: 저장된 첫 번째 원소의 인덱스(마지막 삭제 위치)
  
  - rear: 저장된 마지막 원소의 인덱스

- 상태 표현
  ![](0817_0818_assets/2023-08-17-09-19-41-image.png)

- 큐의 구현
  
  ![](0817_0818_assets/2023-08-17-09-20-33-image.png)
  
  <img src="0817_0818_assets/2023-08-17-09-20-45-image.png" title="" alt="" width="423">
  
  `isFull()`은 그냥 디버깅 용도(생략 가능)
  
  <img src="0817_0818_assets/2023-08-17-09-22-01-image.png" title="" alt="" width="400">
  <img src="0817_0818_assets/2023-08-17-09-35-34-image.png" title="" alt="" width="398">
  <img src="0817_0818_assets/2023-08-17-09-36-44-image.png" title="" alt="" width="470">

- 코드
  
  - front, rear 사용
    ![](0817_0818_assets/2023-08-17-21-31-41-image.png)
  
  - 메소드 사용
    ![](0817_0818_assets/2023-08-17-21-32-59-image.png)
  
  - deque 사용
    
    ![](0817_0818_assets/2023-08-17-21-34-36-image.png)

- 함수 이용
  ![](0817_0818_assets/2023-08-17-21-36-22-image.png)
  ![](0817_0818_assets/2023-08-17-21-36-34-image.png)

### 원형 큐

- 선형 큐 이용시의 문제점
  
  <img src="0817_0818_assets/2023-08-17-10-02-38-image.png" title="" alt="" width="458">
  <img src="0817_0818_assets/2023-08-17-10-03-25-image.png" title="" alt="" width="444">

- 원형 큐의 구조
  
  <img src="0817_0818_assets/2023-08-17-10-08-52-image.png" title="" alt="" width="424">
  <img src="0817_0818_assets/2023-08-17-10-09-13-image.png" title="" alt="" width="447">
  
  이렇게 하지 않으면 공백과 포화 상태 구분 불가

- 원형 큐의 연산 과정
  
  <img src="0817_0818_assets/2023-08-17-10-09-37-image.png" title="" alt="" width="403">
  <img src="0817_0818_assets/2023-08-17-10-11-25-image.png" title="" alt="" width="398">
  <img title="" src="0817_0818_assets/2023-08-17-10-11-46-image.png" alt="" width="435">
  
  6번이 꽉 찬 상태(front 자리는 비어있어야 하므로)

- 원형 큐의 구현
  ![](0817_0818_assets/2023-08-17-10-12-56-image.png)<img src="0817_0818_assets/2023-08-17-10-13-06-image.png" title="" alt="" width="430"><img src="0817_0818_assets/2023-08-17-10-13-25-image.png" title="" alt="" width="446"><img src="0817_0818_assets/2023-08-17-10-13-36-image.png" title="" alt="" width="413"><img src="0817_0818_assets/2023-08-17-10-13-49-image.png" title="" alt="" width="422">

- 코드
  ![](0817_0818_assets/2023-08-17-21-37-31-image.png)

### 우선순위 큐

- 우선순의 큐의 특성
  
  - 우선순위를 가진 항목들을 저장하는 큐
  
  - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.

- 우선 순위 큐의 적용 분야(참고)
  
  - 시뮬레이션 시스템
  
  - 네트워크 트래픽 제어
  
  - 운영체제의 테스크 스케줄링

- 우선 순위 큐의 구현 및 기본연산 

<img title="" src="0817_0818_assets/2023-08-17-10-30-40-image.png" alt="" width="402">

- 배열을 이용한 우선순위 큐
  
  <img src="0817_0818_assets/2023-08-17-10-31-24-image.png" title="" alt="" width="459">

- 큐의 활용: 버퍼(Buffer)(참고)
  
  <img src="0817_0818_assets/2023-08-17-10-32-30-image.png" title="" alt="" width="454">

### BFS

- 그래프를 탐색하는 방법에는 크게 2 가지
  
  - 깊이 우선 탐색(DFS)
  
  - 너비 우선 탐색(BFS) 

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

- cf) 거리 순 탐색을 할 때 유리

- 거리별로, 가까운 놈은...(힌트)

- 그림
  
  <img src="0817_0818_assets/2023-08-18-09-06-05-image.png" title="" alt="" width="354">

- BFS 알고리즘(아래껀 몰라도 됨, 더 아래것만 알면 됨)
  (deQ 할 때 방문체크)
  ![](0817_0818_assets/2023-08-18-09-09-36-image.png)

- 다른 예
  ![](0817_0818_assets/2023-08-18-09-28-40-image.png)
  
  enQ할 때 방문 체크

<img src="0817_0818_assets/2023-08-18-09-29-17-image.png" title="" alt="" width="478">

  **visited 위치 차이** (이미 처리했어요..느낌, 이미 줄 서있으니 또 세우지 마!)
  주로 위의 방식을 더 위의 방식보다 권함

  **여러 경로로 이어져 있으면 더 빠른 순으로 탐색된다는 특징이 있다.** (잘 생각해보면 됨)

  정점과의 거리와 관련된 방식으로 문제 많이 냄(너무 단순하니 티 안나게 꼬아서 낸다고 함)

  `visited[i] = visited[t] + 1`: 거리 세어주는 느낌(위의 정점 visited값 +1) (위에 오타있음)

  ~~가장 많이 걸리는 시간이나 거리 물어봤을 때 1 빼는 이유: 자기 자신의 땅에서 자기 자신으로 가는 것 고려~~

- 연습문제
  
  <img src="0817_0818_assets/2023-08-18-10-02-38-image.png" title="" alt="" width="440">
  <img src="0817_0818_assets/2023-08-18-10-02-27-image.png" title="" alt="" width="232">
  1 부터 시작할 때
  <img src="0817_0818_assets/2023-08-18-10-03-48-image.png" title="" alt="" width="233">
  2부터 시작할 때
