# 게임 서버의 종류와 특징

## 게임 통신 방식에 따른 서버 분류

플레이어끼리 반드시 실시간으로 상호작용 하는가?

- 실시간 통신이 반드시 필요 → 동기적 서버 구현
  
  - Stateful 통신을 이용한 게임 서버 제작
  - TCP(연결 지향으로 데이터가 확실하게 감)/UDP(데이터 손실 가능성이 있음)를 이용한 소켓 통신 / RPC (Remote Procedure Calls) 사용
  - 단 재화, 상점 아에팀 구매 등 단순한 저장 데이터의 경우 웹서버 / WAS에서 분산 처리

- 실시간 통신이 필요하지 않는 경우 → 비동기적으로 서버 구현
  
  - Stateless 통신을 이용한 게임 서버 제작
  - Http를 이용한 웹 서버 / WAS로 제작 → 일반 웹어플리케이션과 구조가 크게 다르지 않음
  - 채팅 등 간단한 소통은 Websocket 사용

## 비동기적 게임 서버의 특징

### Stateless한 서버 구성

- Client 인증, 게임 결과 및 재화, 상점 구매 등 정적 데이터 저장 - 플레이어와 서버가 단 반향 통신
- 서버의 수평적 확장(Scale Out)이 용이하며, 게임 플레이가 대부분 Local에서 이루어지기 때문에 Client 보안에 취약
- 대표적 게임 장르: 키우기, 방치형, 퍼즐, 수집형 등 랭킹 경쟁 류의 모바일 게임

## 동기적 게임 서버의 특징

### Stateful한 서버 구성

- Client안의 게임 캐릭터 움직임 및 체력, 공격 등 동적 데이터 관리 - 플레이어와 서버가 양 방향 통신
- Client가 서버에 행동을 요청하고 그 결과를 처리한 뒤, 접속되어 있는 모든 Client에게 데이터를 보내준다 → 데이터 동기화(Broadcast)
- 모든 Client가 하나의 서버에 연결되어 있으므로 수평적 확장이 어렵고 수직적 확장(Scale Up)으로 서비스를 운영하는 경우가 많음 → 연결 정보가 다 연결되어 있어서 수평적 확장이 어려움
- 수평적 확장을 하기 위해서 각각의 Game Server를 관리하는 또 다른 서버를 구성해야 함 (Master Server, Center Server)
- 대표적 게임 장르: 실시간 대전 게임, MMORPG 등의 동시 접속이 반드시 필요한 온라인 게임

# 포톤 클라우드와 통신 방식

## 포톤 클라우드의 구조

### 유니티 전용 네트워크 구조

- Room 기반의 서버 아키텍쳐를 가지고 있으며, 소규모 인원이 한 방에 진행하는 게임들에 적합한 엔진
- Name Server(붙을 수 있는 지역 Return) / Master Server / Game Server 로 구성되어 있음

### PhotonView를 이용한 동기화

- 게임 안의 Object 중 움직임이나 회전 등 실시간으로 동기화가 필요한 경우 사용
- Observeer Pattrern으로 설계되어 있음

### RPC(Remote Procedure Calls)를 이용한 동기화

- 게임 안의 Object에게 그 객체의 특정 함수를 직접 실행하도록 요청
- 단 한번의 호출로 Local상에서 Client의 움직임을 동기화 하는 가능
- 각각의 Client 상에서 로직이 발생하므로 네트워크 통신은 더 이상 발생하지 않음

## PhotonView의 통신 예시 (네트워크)

### 게임 안의 오브젝트와 PhotonView 객체를 1:1 매칭 시킴

- PhotonView 객체가 Client 안의 오브젝트의 움직임을 감시하다가 이동의 변화가 있는 경우 방안의 모든 Client에게 알림
- 동기화를 하고 싶은 Object에 PhotonView를 붙이는 것만으로도 손쉽게 동기화 가능
- 모든 클라이언트가 실시간으로 동시에 보여져야 하는 객체들에게 적용이 필요
- 네트워크 부하가 상당히 많을 수 있으므로 반드시 필요한 경우에만 적용

## RPC(Remote Procedure Calls)의 통신 예시 (로컬)

### RPC - Client가 Photon Cloud를 통해 각가 다른 Client의 함수를 직접 호출

- Client 안의 캐릭터가 가진 함수를 네트워크를 통해 가각 1회씩 호출함으로 화면 상의 동기화가 가능함
- 함수 실행이 Client에서 행히짐으로 서버의 연산 비용을 줄이고 Local 환경에서 직접 동기화
- 단 코드 로직이 Client 안에 있으므로 보안에 상당히 취약함
- 프레임 단위에 따라 진행되기 때문에 지연이 살짝 있을 수나 있으나 거의 없음

# 소켓 프로그래밍의 이해

## 소켓(Socket)이란?

### 소켓의 정의

- 소켓은 네트워크 상에서 돌아가는 두개의 프로그램 (Client - Server) 간의 접속됨
- 소켓은 IP와 port의 조합으로 이루어진 엔드포인트를 바탕으로 연결됨
- Client 측의 소켓 연결 요청과 Server 측의 소켓 연결 수락이 이루어지며 데이터를 양방향으로 주고받을 수 있음

## 소켓 통신의 특징

- 패킷이라는 형식화된 데이터 메모리 단위를 주고받아 통신함
- Client와 Server가 특정 port를 열어서 실시간으로 양방향 통신을 하는 방식
- Stateful Protocol-server가 Client의 상태를 저장하고 있음 (임의로 끊지 않는 이상 서로 연결 유지)
- DB를 통해 데이터를 주고받을 수도 있고, 임시로 데이터를 서버 프로그램 자체 내에서 생성해서 가지고 있을 수도 있음
- 서버 자체의 메모리에 유저 데이터를 저장하고 있음

## Packet Data 만들기

### Packet Data의 정의

- 연결된 Client와 Server가 통신을 주고 받기위한 일종의 데이터 규약
- 패킷의 공통 헤더와 담을 메시지를 버퍼를 이용해서 확장성 있게 구현 가능
- Client가 보낸 패킷은 서버는 공통 헤더를 통해 얼마만큼 버퍼를 파싱할 지를 결정
- 파싱된 데이터를 통해 Client가 원하는 정보를 서버에서 다시 Packet Data로 만들어서 보냄

## 소켓 통신의 동작 원리

### 싱글 스레드 소켓 서버의 구조

Processing 과정이 하나의 queue(통로)로 인해서 왔다 갔다 함

### 멀티 스레드 소켓 서버의 구조

Processing 과정이 하나의 독립된 스레드로 생성하여, 소켓 통신이 일어날 때 마다 그 개수만큼 스레드가 생김

공유 데이터 접근 시 데이터 무결성 처리 필요

# 간략한 PvP 서버 동작 예시

보여지는 데이터와 서버의 데이터가 완전히 동기화가 되어야 함 **(동기화의 싸움!)**
