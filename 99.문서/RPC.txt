Replication : 서버에서 클라로 전파하는 개념 (반대는 안됨!!!!!!), 그래서 SetReplicates(bool 값), SetReplicateMovement(bool 값) 함수들은 서버에서만 실행되는 함수라고 생각해도 됨!!! 
(어떤 것을 전파해줄래? 설정하는 것이 필요. (참고, Movement는 너무 많이 쓰여서 기본 지원))

그럼 어떤 것을 전파해줄려고 할 때 어떻게?
- Variable Replication (변수 복제)방식
-- Replicated: 값만 복제
-- RepNotify: 값이 바뀔 때 알람을 줌(콜백), C++에선 ReplicatedUsing이라고 함. (서버는 값을 복제할 필요가 없으므로 콜백되지 않아 따로 콜백함수를 넣어줘야 된다.)
-- C++로 작업을 할 때는 GetLifetimeReplicatedProps를 추가해줘야 된다. 그리고 DOREPLIFETIME을 통해 얘를 추적하고 싶다는 것을 등록 (DOREPLIFETIME_CONDITION으로 조건을 붙일 수도 있음)

- RPC (Remote Procedure Call) (원격으로 "함수"를 호출한다.)
-- Relication은 서버에서 뭔가 이루어지고 그걸 클라한테 뿌리는 개념이다보니 나는 클라에서 하고 싶어도 못함. (서버에서 클라로 가는 것만 되므로...), 근데 클라에서 시작해서 서버에 요청해야 되는 경우가 굉장히 많다. 그래서 탄생한 것이 RPC!
-- 구현부는 cppWhr 해당함수_Implementation을 통해서 구현
-- Multicast - 모든 클라에게 해당 함수를 싹 다 호출하겠다. (호출하는 대상은 무조건 서버)
-- Run on Server - 서버야 이 함수좀 실행해줘. (실행(호출)하는 주체는 클라), 소유권의 개념이 들어감(owning client일 때만 보낼 수 있음), 주의할 점으로 다른 클라이언트가 발생시킨 이벤트도, 소유권을 가진 클라이언트가 특정 상황에 따라 인지할 수 있다. 필요할 경우, IsLocallyControlled 함수를 사용해 클라이언트가 실제로 해당 객체를 제어 중인지 확인하고, 이벤트가 의도한 대로 실행되도록 조정할 수 있다. (해킹도 조심하자!!, WithValidation 옵션이 있음. - cpp쪽 해당함수_Validate를 작성하여 치팅 우려되는 것을 잡을 수 있음)
-- Run on owning Client - 서버에서 클라이언트에게 보내는 RPC (모든 클라에게 뿌리는 것이 아닌 특정 클라에게만 뿌림) (얘도 소유권의 개념이 들어가 있음), 주의할 점으로 서버는 소유권이 없을때도 초기 상태(소유권 x)일때 자기 자신(서버)이 함수를 호출할 수 있음.... (리슨 서버일 때.) 

- Variable Replication Vs RPC
-- 두 방식 모두 가능하다고 하면 Variable Replication로 구현하는 것이 좋다. (패킷 낭비 줄임.) (그리고 변수 복제방식은 바로 보내는 게 아니라 일정 주기를 세팅할 수도 있음, 반면 RPC는 함수이다보니 한번 실행되면 끝까지 실행해야 됨.)
-- 변수로만으론 케어가 안될 경우 RPC를 이용


------------------------------GPT-------------------------
Replication: 서버에서 클라이언트로 데이터를 전파하는 개념입니다. 클라이언트에서 서버로는 직접 전파가 불가능하므로, 복제는 오직 서버에서 클라이언트로만 이루어집니다. 따라서 SetReplicates(bool)와 SetReplicateMovement(bool) 함수들은 서버에서만 호출되는 함수라고 생각할 수 있습니다. 서버에서 어떤 데이터를 클라이언트에게 전파할지 설정하는 것이 필요하며, 특히 Movement는 너무 자주 사용되어 기본적으로 지원됩니다.

전파할 데이터를 설정하는 방법
Variable Replication (변수 복제 방식)

Replicated: 값만 단순히 복제됩니다.
RepNotify: 값이 변경될 때 알림(콜백)을 받습니다. C++에서는 ReplicatedUsing으로 정의됩니다. 서버는 값 복제가 필요 없으므로 콜백이 발생하지 않으며, 따로 콜백 함수를 작성해줘야 합니다.
C++에서 작업할 때는 GetLifetimeReplicatedProps 함수를 추가해야 하며, DOREPLIFETIME 매크로를 사용해 해당 변수를 복제 대상에 등록합니다. 필요 시 DOREPLIFETIME_CONDITION을 사용해 조건을 붙일 수도 있습니다.
RPC (Remote Procedure Call)

Replication은 서버에서 발생한 데이터를 클라이언트로 전파하는 방식이므로, 클라이언트에서 서버로 직접 전파할 수 없습니다. 하지만 클라이언트가 서버에 요청을 보내야 하는 상황이 많습니다. 이를 해결하기 위해 RPC가 존재합니다.

C++에서 구현할 때는 _Implementation을 붙여 함수의 본문을 정의합니다.

Multicast: 모든 클라이언트에게 해당 함수를 호출합니다. (호출 주체는 항상 서버)
Run on Server: 클라이언트가 서버에 특정 함수를 실행하도록 요청하는 방식입니다. 이때 클라이언트는 객체의 소유권을 가지고 있어야만 RPC 호출이 가능합니다. 다른 클라이언트가 발생시킨 이벤트도 특정 조건에 따라 소유 클라이언트가 인지할 수 있습니다. 필요하다면 IsLocallyControlled 함수를 사용해 클라이언트가 실제로 객체를 제어 중인지 확인하고, 이를 기반으로 이벤트를 조정할 수 있습니다. 이 경우 해킹에 주의해야 하며, WithValidation 옵션을 사용해 _Validate 함수를 작성해 치팅 가능성을 차단할 수 있습니다.
Run on owning Client: 서버에서 특정 클라이언트에게 RPC를 보내는 방식입니다. 모든 클라이언트가 아닌 특정 소유 클라이언트에게만 전송되며, 소유권 개념이 포함됩니다. 리슨 서버의 경우 서버는 소유권이 없을 때도, 초기 상태에서 자기 자신에게 함수를 호출할 수 있습니다.
Variable Replication vs RPC
두 방식 모두 사용 가능할 때는 Variable Replication을 사용하는 것이 좋습니다. 이는 네트워크 패킷 낭비를 줄일 수 있으며, 변수 복제 방식은 일정 주기를 설정해 데이터를 전송할 수 있습니다. 반면, RPC는 함수 호출이므로 호출되면 끝까지 실행됩니다.
변수를 이용한 복제가 충분하지 않을 때는 RPC를 사용하는 것이 바람직합니다.



------------------------질문----------------------------
궁금한게 있는데 소유권 관련된 것은 서버가 관리해? (GPT)

네, 언리얼 엔진에서 **소유권(ownership)**은 서버가 관리합니다. 멀티플레이어 환경에서 객체의 소유권은 주로 서버에서 결정되며, 서버는 각 객체의 소유 클라이언트(owning client)를 추적하고 제어합니다.

소유권 관련 핵심 개념
소유권의 기본 원칙:

서버는 모든 객체의 소유권을 관리하며, 각 클라이언트는 서버로부터 자신의 소유 객체에 대한 권한을 부여받습니다.
소유권은 보통 플레이어가 제어하는 Pawn, Character와 같은 객체에서 중요하게 다뤄집니다. 이 객체들은 플레이어가 직접 조종하는 주체이기 때문에, 소유권이 필요한 경우가 많습니다.
소유 클라이언트(owning client):

소유 클라이언트는 특정 객체에 대한 권한을 가지는 클라이언트입니다. 예를 들어, 클라이언트 A가 캐릭터 A를 소유하고 있을 때, 서버는 캐릭터 A의 소유자가 클라이언트 A라는 정보를 알고 있으며, 이를 통해 특정 함수나 데이터 전송을 관리합니다.
클라이언트가 서버에게 Run on Server와 같은 RPC를 호출하려면, 해당 객체의 소유 클라이언트여야 합니다.
소유권 관리:

서버는 각 객체의 Owner 속성을 통해 소유권을 관리합니다. 이 속성은 객체가 어느 클라이언트에게 속하는지 나타내며, 이를 기반으로 RPC 호출이나 변수 복제가 이루어집니다.
소유권이 있는 클라이언트만 특정 RPC를 서버에 요청할 수 있으며, 이는 게임 내에서 보안 및 권한 관리를 용이하게 만듭니다.
Listen Server vs Dedicated Server:

Dedicated Server에서는 서버가 모든 객체를 소유하고 있으며, 각 클라이언트는 서버가 정해준 소유권에 따라 객체를 제어합니다.
Listen Server의 경우, 서버 자체도 플레이어로 참여할 수 있기 때문에 서버가 소유하는 객체도 존재할 수 있습니다. 이 경우, 서버는 클라이언트와 자신의 소유 객체를 구분해 관리합니다.
IsLocallyControlled와 소유권 확인
IsLocallyControlled는 클라이언트가 객체를 직접 제어하고 있는지 여부를 확인하는 함수로, 로컬 클라이언트가 제어하는 객체인지 확인하는 데 사용됩니다.
소유권이 있는 클라이언트가 해당 객체를 직접 조작하고 있는지 체크할 때 활용되며, 소유권은 서버에서 관리되더라도 로컬 제어는 클라이언트에서 확인할 수 있습니다.
따라서 소유권(ownership) 관련된 모든 핵심 처리는 서버가 담당하며, 클라이언트는 서버에서 부여된 소유권을 바탕으로 객체를 제어하거나 RPC를 요청하게 됩니다.